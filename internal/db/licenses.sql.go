// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: licenses.sql

package db

import (
	"context"
	"database/sql"
)

const claimLicense = `-- name: ClaimLicense :exec
UPDATE licenses
SET node_id = ?, last_claimed_at = CURRENT_TIMESTAMP, claims = claims + 1
WHERE id = ? AND node_id IS NULL
`

type ClaimLicenseParams struct {
	NodeID sql.NullInt64 `json:"node_id"`
	ID     string        `json:"id"`
}

func (q *Queries) ClaimLicense(ctx context.Context, arg ClaimLicenseParams) error {
	_, err := q.db.ExecContext(ctx, claimLicense, arg.NodeID, arg.ID)
	return err
}

const deleteLicenseByID = `-- name: DeleteLicenseByID :exec
DELETE FROM licenses
WHERE id = ?
`

func (q *Queries) DeleteLicenseByID(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLicenseByID, id)
	return err
}

const getAllLicenses = `-- name: GetAllLicenses :many
SELECT id, file, key, claims, last_claimed_at, last_released_at, node_id
FROM licenses
ORDER BY id
`

func (q *Queries) GetAllLicenses(ctx context.Context) ([]License, error) {
	rows, err := q.db.QueryContext(ctx, getAllLicenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []License
	for rows.Next() {
		var i License
		if err := rows.Scan(
			&i.ID,
			&i.File,
			&i.Key,
			&i.Claims,
			&i.LastClaimedAt,
			&i.LastReleasedAt,
			&i.NodeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLicenseByID = `-- name: GetLicenseByID :one
SELECT id, file, key, claims, last_claimed_at, last_released_at, node_id
FROM licenses
WHERE id = ?
`

func (q *Queries) GetLicenseByID(ctx context.Context, id string) (License, error) {
	row := q.db.QueryRowContext(ctx, getLicenseByID, id)
	var i License
	err := row.Scan(
		&i.ID,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
	)
	return i, err
}

const getUnclaimedLicense = `-- name: GetUnclaimedLicense :one
SELECT id, file, key, claims, last_claimed_at, last_released_at, node_id
FROM licenses
WHERE node_id IS NULL
LIMIT 1
`

func (q *Queries) GetUnclaimedLicense(ctx context.Context) (License, error) {
	row := q.db.QueryRowContext(ctx, getUnclaimedLicense)
	var i License
	err := row.Scan(
		&i.ID,
		&i.File,
		&i.Key,
		&i.Claims,
		&i.LastClaimedAt,
		&i.LastReleasedAt,
		&i.NodeID,
	)
	return i, err
}

const insertLicense = `-- name: InsertLicense :exec
INSERT INTO licenses (id, file, key, claims, node_id)
VALUES (?, ?, ?, ?, NULL)
`

type InsertLicenseParams struct {
	ID     string        `json:"id"`
	File   []byte        `json:"file"`
	Key    string        `json:"key"`
	Claims sql.NullInt64 `json:"claims"`
}

func (q *Queries) InsertLicense(ctx context.Context, arg InsertLicenseParams) error {
	_, err := q.db.ExecContext(ctx, insertLicense,
		arg.ID,
		arg.File,
		arg.Key,
		arg.Claims,
	)
	return err
}

const releaseLicenseByID = `-- name: ReleaseLicenseByID :exec
UPDATE licenses
SET node_id = NULL, last_released_at = CURRENT_TIMESTAMP
WHERE id = ? AND node_id IS NOT NULL
`

func (q *Queries) ReleaseLicenseByID(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, releaseLicenseByID, id)
	return err
}

const releaseLicenseByNodeID = `-- name: ReleaseLicenseByNodeID :exec
UPDATE licenses
SET node_id = NULL, last_released_at = CURRENT_TIMESTAMP
WHERE node_id = ?
`

func (q *Queries) ReleaseLicenseByNodeID(ctx context.Context, nodeID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, releaseLicenseByNodeID, nodeID)
	return err
}
